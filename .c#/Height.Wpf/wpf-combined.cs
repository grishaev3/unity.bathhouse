// File generated by dotnet-combine at 2026-01-10__12_38_54

using System.Configuration;
using System.Data;
using System.IO;
using System.Numerics;
using System.Text;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;





// App.xaml.cs
namespace Height.Wpf
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }

}


// Calculator.cs
namespace Height.Wpf
{
    public class Calculator
    {
        private int _textureLength;

        private readonly Vector2 _terrainTopLeft;
        private readonly Vector2 _terrainBottomRight;
        private readonly HeightData[] _heightData;

        private readonly float _unitysizeZ, _unitysizeX;
        private readonly float _minHeight, _maxHeight;

        public Calculator(int textureLength, Vector2 terrainTopLeft, Vector2 terrainBottomRight, HeightData[] heightData)
        {
            _textureLength = textureLength;

            _terrainTopLeft = terrainTopLeft;
            _terrainBottomRight = terrainBottomRight;

            _heightData = heightData;

            _unitysizeX = Math.Abs(_terrainTopLeft.X - _terrainBottomRight.X);  // 50
            _unitysizeZ = Math.Abs(_terrainTopLeft.Y - _terrainBottomRight.Y);  // 50

            _minHeight = heightData.Min(x => x.Height);
            _maxHeight = heightData.Max(x => x.Height);
        }

        public byte GetColor(int x, int y)
        {
            y = _textureLength - y; // Переворачиваем по Y

            var (_, unityZ) = Calc(x, y);

            var normalizeHeight = GetNormalizeHeight(unityZ);

            var result = (byte)Math.Floor(normalizeHeight * 255f);

            return result;
        }

        public float GatAbsoluteHeight(float unityZ)
        {
            var (_heightDataA, _heightDataB) = FindByZ(unityZ);

            var currentHeight = GetHeightByZ(unityZ, _heightDataA, _heightDataB);
            return currentHeight;
        }

        public float GetNormalizeHeight(float unityZ)
        {
            float currentHeight = GatAbsoluteHeight(unityZ);

            var normalizeHeight = Interpolate(_minHeight, _maxHeight, currentHeight);

            return normalizeHeight;
        }

        private (float unityX, float unityZ) Calc(int x, int y)
        {
            return
            (
                _terrainTopLeft.X + ((float)x / _textureLength) * _unitysizeX,
                _terrainTopLeft.Y - ((float)y / _textureLength) * _unitysizeZ
            );
        }

        private (HeightData a, HeightData b) FindByZ(float unityZ)
        {
            for (int i = 0; i < _heightData.Length - 1; i++)
            {
                if (_heightData[i].UnityZ <= unityZ && unityZ <= _heightData[i + 1].UnityZ)
                {
                    return (_heightData[i], _heightData[i + 1]);
                }
            }

            throw new Exception(nameof(FindByZ));
        }

        private static float GetHeightByZ(float unityZ, HeightData a, HeightData b)
        {
            // Нормализуем X к [0,1]
            float t = (unityZ - a.UnityZ) / (b.UnityZ - a.UnityZ);

            // Ограничиваем t в [0,1] (clamp)
            t = MathF.Max(0f, MathF.Min(1f, t));

            // Линейная интерполяция Y: a.Y + t * (b.Y - a.Y)
            return a.Height + t * (b.Height - a.Height);
        }

        private static float Interpolate(float a, float b, float c)
        {
            if (a == b) return 0f; // Избегаем деления на ноль
            return (c - a) / (b - a);
        }

        /*
        public (float u, float v) Calc(float unityX, float unityZ)
        {
            return
            (
                Math.Abs((unityX - _terrainTopLeft.X) / _unitysizeX * _textureLength),
                Math.Abs((unityZ - _terrainTopLeft.Y) / _unitysizeZ * _textureLength)
            );
        }
        */
    }
}


// GradientRenderer.cs
namespace Height.Wpf
{
    public class GradientRenderer : FrameworkElement
    {
        private WriteableBitmap? _lastBitmap;

        private readonly Calculator _calculator;

        private readonly int _textureLength = 1025;

        public GradientRenderer()
        {
            HeightData[] heightData = new HeightData[] {
                new(-25.00f, -1.5f),
                new(-15.50f, -1.2f),   // низ к 3уч
                new(-4.00f, -0.8f),
                new(-2.00f, -0.6f),
                new(-0.00f, -0.4f),
                new(+5.00f, -0.0f),
                new(+18.5f, -0.25f),     // верх к 2уч
                new(+23.1f, +0.50f),     // верх к 3уч
                new(+25.0f, +0.50f)
            };

            _calculator = new(_textureLength,
                new Vector2(-25f, +25f),
                new Vector2(+25f, -25f),
                heightData);

            //SaveTo("C:\\TEMP\\1.txt");
        }

        protected override void OnRender(DrawingContext drawingContext)
        {
            _lastBitmap = GenerateBitmap(_textureLength, _textureLength);

            drawingContext.DrawImage(_lastBitmap, new Rect(0, 0, _textureLength, _textureLength));
        }

        public WriteableBitmap CreateBitmap()
        {
            if (_lastBitmap != null)
            {
                return _lastBitmap.Clone();
            }

            return GenerateBitmap(_textureLength, _textureLength);
        }

        protected override void OnRenderSizeChanged(SizeChangedInfo sizeInfo)
        {
            base.OnRenderSizeChanged(sizeInfo);

            _lastBitmap = null; // Сбрасываем кэш

            InvalidateVisual();
        }

        private WriteableBitmap GenerateBitmap(int width, int height)
        {
            byte[] pixels = new byte[width * height * 4];
            //var y = 1024;
            for (int y = 0; y < height; y++)
            {
                byte intensity = _calculator.GetColor(default, y);

                for (int x = 0; x < width; x++)
                {
                    int pixelIndex = (y * width + x) * 4;
                    pixels[pixelIndex + 0] = intensity;
                    pixels[pixelIndex + 1] = intensity;
                    pixels[pixelIndex + 2] = intensity;
                    pixels[pixelIndex + 3] = 255;
                }
            }

            var bitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Pbgra32, null);
            bitmap.WritePixels(new Int32Rect(0, 0, width, height), pixels, width * 4, 0);
            return bitmap;
        }

        private void SaveTo(string name)
        {
            StringBuilder sb = new StringBuilder();
            for (var f = -25f; f <= 25f; f += 1.0f)
            {
                var abs = _calculator.GatAbsoluteHeight(f);
                var norm = _calculator.GetNormalizeHeight(f);
                sb.AppendLine($"{f}: {abs.ToString()}");
            }
            File.WriteAllText(name, sb.ToString());
        }
    }
}


// HeightData.cs
namespace Height.Wpf
{
    public struct HeightData
    {
        public float UnityZ;

        public float Height;

        public HeightData(float unityZ, float height)
        {
            UnityZ = unityZ;
            Height = height;
        }
    }
}


// MainWindow.xaml.cs
namespace Height.Wpf
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            FocusManager.SetFocusedElement(this, this);
        }

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                SaveGradientToBmp();
                e.Handled = true;
            }
        }

        private void SaveGradientToBmp()
        {
            var bitmap = gradientRenderer.CreateBitmap();

            string fileName = $"gradient_{System.DateTime.Now:yyyyMMdd_HHmmss}.bmp";
            string filePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), fileName);

            using (var fileStream = File.Create(filePath))
            {
                BmpBitmapEncoder encoder = new();
                encoder.Frames.Add(BitmapFrame.Create(bitmap));
                encoder.Save(fileStream);
            }

            Title = $"Сохранено: {fileName}";
        }

    }
}
